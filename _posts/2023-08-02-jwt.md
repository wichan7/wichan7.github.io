---
title: "웹 기술 - JWT"
categories: 
  - web
tags:
  - jwt
---

## 들어가기에 앞서
이전 '웹기술 - 인증' 편의 후속이다 : [바로가기](https://wichan7.github.io/web/web-auth/)  
nodejs로 구현되었고 npm에 등록된 jsonwebtoken 라이브러리를 활용했다 : [바로가기](https://www.npmjs.com/package/jsonwebtoken)  

## JWT
JSON Web Token의 약자로 JSON 형식으로 구성되어 Base64로 인코딩된 웹 토큰 또는 그 시스템을 말한다.  
JWT는 `Header.Payload.Signature` 세가지 요소로 구성되며, 각 요소는 .(dot)으로 구분되고 Base64로 인코딩 되어있다.  

### Header
Header는 토큰의 유형과 사용중인 서명 알고리즘(ex: HMAC256, RS256...)의 두 부분으로 구성된다.
``` json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### Payload
Payload는 Claim으로 구성되며, Claim은 데이터와 같은 의미로 이해하면 된다.  
Claim은 Registered Claim, Public Claim, Private Claim 세가지로 분류된다.  

**Registered Claim**: 미리 정의된, 사용하면 좋은 필드.  

fieldName|description
---:|---
iss|토큰 발급자 (issuer)
sub|토큰 제목 (subject)
aud|토큰 대상자 (audience)
exp|토큰의 만료시간 (expiraton), 시간은 NumericDate 형식으로 되어있어야 하며 (예: 1480849147370) 언제나 현재 시간보다 이후로 설정되어있어야합니다.
nbf|Not Before를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.
iat|토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age 가 얼마나 되었는지 판단 할 수 있습니다.
jti|JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.

**Public Claim**: '[어떤 정보가 필요하면, 이런 이름을 쓰면 좋아](https://www.iana.org/assignments/jwt/jwt.xhtml)' 라고 미리 정의한 필드.  

**Private Claim**: 주고받길 원하는 데이터가 public claim 리스트에 없다면 직접 만들어 쓰면 된다.  
``` json
// 예를 들어...
{
  "오늘점심": "순대국"
}
```

### Signature
Signature는 header와 payload를 secret으로 단방향 암호화(=해싱)한 값이다.  
``` javascript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64urlEncode(payload),
  secretOrPrivateKey
)
```
JWT 검증 서버는 Signature가 유효한지 검사해 정상적인 요청인지 확인할 수 있다.  

## 구현
jwt.sign으로 서명하면 Token이 생성되고, 필요한 경우 jwt.verify로 검증한다.  

``` javascript
import fs from 'fs'
import jwt from 'jsonwebtoken'
import dotenv from 'dotenv'

dotenv.config();

const SECRET = process.env.SECRET;
const payload = {
    foo: "bar"
};

/**
 * HMAC256
 */
let token_hmac = jwt.sign(payload, SECRET, {expiresIn: "1m"});

/**
 * RS256
 */
const privateKey = fs.readFileSync('./my.key', 'utf8');
let token_rs = jwt.sign(payload, privateKey, {algorithm: "RS256", expiresIn: "1m"});

/**
 * verify
 */
console.log(jwt.verify(token_hmac, SECRET));
console.log(jwt.verify(token_rs, privateKey));
```

아래 명령으로 RSA private key를 얻을 수 있다.
```
genrsa -out privateKey.key 2048
```

실제 서비스에서는 jwt.sign으로 생성한 토큰을 브라우저에 저장하고, 어떤 자원의 요청시마다 token을 verify할 수 있다.  

## Refresh Token
그 구조상 JWT는 서버에서 토큰의 유효기간을 만료시킬 수 없다. 일반적으로는 여러 정보보호의 목적으로 토큰을 두 쌍으로 관리한다.  
바로 Access Token과 Refresh Token이다. Access Token의 유효 기간은 짧게 두고, Refresh Token의 기한은 길게 준다.  
Access Token이 만료되면 Refresh Token으로 새로운 Access Token을 발급받을 수 있게 된다.  

근데 Refresh Token이 털리면 답이 없는 것 아닌가?  
=> 맞다. Refresh Token이 유출되면 Access Token을 계속 발급받을 수 있게 된다.  

그래서 